<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Roadshow Studio v11a3b - iPhone â†’ U87 (Epoch 319)</title>
    <style>
        @font-face {
            font-family: 'ABC Camera Plain';
            src: url('/fonts/ABCCameraPlain-Regular-Trial.woff2') format('woff2'),
                 url('/fonts/ABCCameraPlain-Regular-Trial.woff') format('woff');
            font-weight: 400;
            font-style: normal;
        }

        @font-face {
            font-family: 'ABC Diatype Rounded';
            src: url('/fonts/ABCDiatypeRounded-Regular-Trial.woff2') format('woff2'),
                 url('/fonts/ABCDiatypeRounded-Regular-Trial.woff') format('woff');
            font-weight: 400;
            font-style: normal;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            /* Strict color palette */
            --black-primary: #0f0f10;
            --black-secondary: #1b1c1e;
            --black-tertiary: #141414;
            --white-primary: #f5f6f7;
            --gray-light: #e4e4e6;
            --gray-medium: #dcdcdc;
            --red-primary: #b6575d;
            --red-secondary: #9c4a50;
            --red-tertiary: #ca6d71;
            --teal-primary: #57b6b0;
            --teal-secondary: #4a9c96;
            --teal-tertiary: #6ac8c2;
        }

        body {
            font-family: 'ABC Camera Plain', -apple-system, sans-serif;
            background: var(--white-primary);
            color: var(--black-tertiary);
            overflow-x: hidden;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            touch-action: manipulation;
        }

        .header {
            padding: 30px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            display: flex;
            align-items: baseline;
            gap: 8px;
            position: relative;
        }

        .logo-text {
            font-family: 'ABC Diatype Rounded', sans-serif;
            font-size: 28px;
            font-weight: 400;
            letter-spacing: -0.02em;
        }

        .logo-studio {
            font-family: 'ABC Camera Plain', sans-serif;
            font-size: 18px;
            color: var(--black-secondary);
            font-weight: 400;
        }

        .logo::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 0;
            width: 30px;
            height: 2px;
            background: var(--red-primary);
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .logo:hover::after {
            width: 100%;
        }

        .version {
            font-size: 11px;
            color: var(--black-secondary);
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        /* Model Status Indicator */
        .model-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(15, 15, 16, 0.9);
            color: var(--white-primary);
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 11px;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
        }

        .model-status .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--gray-medium);
            animation: pulse-dot 2s infinite;
        }

        .model-status.connected .status-dot {
            background: #4ade80;
        }

        .model-status.processing .status-dot {
            background: var(--teal-primary);
            animation: pulse-dot 0.5s infinite;
        }

        .model-status.error .status-dot {
            background: var(--red-primary);
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            gap: 30px;
        }

        /* Drop your sound text above event horizon */
        .drop-text {
            font-family: 'ABC Camera Plain', sans-serif;
            font-size: 24px;
            font-weight: 400;
            text-align: center;
            margin-bottom: 20px;
            position: relative;
            z-index: 10;
        }

        .drop-text .sound {
            color: var(--teal-primary);
        }

        /* Wave ripple effect on words */
        @keyframes wave-ripple {
            0% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-4px);
            }
            100% {
                transform: translateY(0);
            }
        }

        .drop-text .word {
            display: inline-block;
            animation: wave-ripple 2s ease-in-out infinite;
        }

        .drop-text .word:nth-child(1) { animation-delay: 0s; }
        .drop-text .word:nth-child(2) { animation-delay: 0.2s; }
        .drop-text .word:nth-child(3) { animation-delay: 0.4s; }

        /* Event Horizon Recording Interface */
        .recording-interface {
            position: relative;
            width: 345px;
            height: 345px;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
        }

        .event-horizon {
            position: absolute;
            width: 100%;
            height: 100%;
            background: var(--black-primary);
            border-radius: 50%;
            overflow: hidden;
            box-shadow: 0 0 60px rgba(15, 15, 16, 0.2);
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .event-horizon::before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            background: conic-gradient(
                from 0deg,
                transparent,
                rgba(182, 87, 93, 0.15) 20deg,
                transparent 40deg,
                rgba(87, 182, 176, 0.15) 80deg,
                transparent 100deg
            );
            animation: rotate 20s linear infinite;
            opacity: 0.5;
        }

        /* Orb emission effect for recording */
        .orb-container {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
        }

        .recording-interface.recording .orb-container {
            display: block;
        }

        .orb {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            opacity: 0;
            animation: emit-orb 3s ease-out infinite;
        }

        .orb.teal {
            background: radial-gradient(circle, rgba(87, 182, 176, 0.8) 0%, rgba(87, 182, 176, 0) 70%);
        }

        .orb.red {
            background: radial-gradient(circle, rgba(182, 87, 93, 0.8) 0%, rgba(182, 87, 93, 0) 70%);
        }

        .orb:nth-child(1) { animation-delay: 0s; }
        .orb:nth-child(2) { animation-delay: 0.5s; }
        .orb:nth-child(3) { animation-delay: 1s; }
        .orb:nth-child(4) { animation-delay: 1.5s; }
        .orb:nth-child(5) { animation-delay: 2s; }
        .orb:nth-child(6) { animation-delay: 2.5s; }

        @keyframes emit-orb {
            0% {
                transform: translate(-50%, -50%) scale(0.2);
                opacity: 0;
                left: 50%;
                top: 50%;
            }
            20% {
                opacity: 0.6;
            }
            100% {
                transform: translate(-50%, -50%) scale(3);
                opacity: 0;
                left: calc(50% + var(--drift-x));
                top: calc(50% + var(--drift-y));
            }
        }

        /* Random drift directions */
        .orb:nth-child(1) { --drift-x: -80px; --drift-y: -60px; }
        .orb:nth-child(2) { --drift-x: 70px; --drift-y: -50px; }
        .orb:nth-child(3) { --drift-x: -60px; --drift-y: 80px; }
        .orb:nth-child(4) { --drift-x: 90px; --drift-y: 40px; }
        .orb:nth-child(5) { --drift-x: -40px; --drift-y: -90px; }
        .orb:nth-child(6) { --drift-x: 50px; --drift-y: 70px; }

        .event-horizon::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(
                circle at center,
                transparent 30%,
                rgba(182, 87, 93, 0.03) 50%,
                rgba(87, 182, 176, 0.03) 70%,
                transparent 100%
            );
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* Pulsating effect - more pronounced */
        .recording-interface.pulse .event-horizon {
            animation: pulsate 1.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .recording-interface.pulse .event-horizon::after {
            opacity: 1;
            animation: flicker-out 1.5s ease-out;
        }

        @keyframes pulsate {
            0% { transform: scale(1); }
            30% { transform: scale(1.08); }
            60% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes flicker-out {
            0% { 
                opacity: 0;
                transform: scale(1);
            }
            10% {
                opacity: 0.8;
                transform: scale(1.15);
            }
            100% {
                opacity: 0;
                transform: scale(1.4);
            }
        }

        @keyframes rotate {
            to { transform: rotate(360deg); }
        }

        .inner-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            height: 90%;
            background: var(--white-primary);
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.3s ease;
        }

        .recording-interface.recording .inner-circle {
            width: 85%;
            height: 85%;
            background: rgba(245, 246, 247, 0.98);
        }

        .interface-text {
            font-family: 'ABC Camera Plain', sans-serif;
            font-size: 22px;
            font-weight: 400;
            text-align: center;
            line-height: 1.3;
        }

        .interface-text .record {
            color: var(--red-primary);
        }

        .interface-text .upload {
            color: var(--teal-primary);
        }

        .recording-time {
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'ABC Diatype Rounded', sans-serif;
            font-size: 14px;
            color: var(--red-primary);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .recording-interface.recording .recording-time {
            opacity: 1;
        }

        /* Waveform Visualization */
        .waveform-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60%;
            height: 40px;
            display: none;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }

        .recording-interface.recording .waveform-container {
            display: flex;
        }

        .waveform-bar {
            width: 3px;
            background: var(--red-primary);
            border-radius: 2px;
            transition: height 0.1s ease;
        }

        /* File Drop Alternative */
        .file-drop-area {
            position: absolute;
            bottom: -80px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            opacity: 0.6;
            transition: opacity 0.3s ease;
        }

        .file-drop-area:hover {
            opacity: 1;
        }

        .file-button {
            background: transparent;
            border: 1px solid var(--gray-medium);
            padding: 8px 16px;
            border-radius: 20px;
            font-family: 'ABC Camera Plain', sans-serif;
            font-size: 12px;
            color: var(--black-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-button:hover {
            border-color: var(--teal-primary);
            color: var(--teal-primary);
        }

        /* Processing State */
        .processing-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(245, 246, 247, 0.98);
            z-index: 100;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            backdrop-filter: blur(10px);
        }

        .processing-text {
            font-family: 'ABC Diatype Rounded', sans-serif;
            font-size: 18px;
            margin-bottom: 10px;
            color: var(--black-tertiary);
        }

        .processing-progress {
            width: 200px;
            height: 2px;
            background: var(--gray-light);
            border-radius: 1px;
            overflow: hidden;
        }

        .processing-progress-bar {
            height: 100%;
            background: var(--red-primary);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Controls Section */
        .controls-section {
            display: none;
            width: 100%;
            max-width: 600px;
            text-align: center;
        }

        .controls-title {
            font-size: 18px;
            margin-bottom: 30px;
            color: var(--black-tertiary);
            font-family: 'ABC Camera Plain', sans-serif;
            font-weight: 400;
        }

        .controls-title .sound {
            color: var(--teal-primary);
        }

        .knobs-container {
            display: flex;
            justify-content: center;
            gap: 50px;
            margin-bottom: 40px;
        }

        .knob-control {
            text-align: center;
        }

        .knob {
            width: 70px;
            height: 70px;
            border: 2px solid var(--black-primary);
            border-radius: 50%;
            position: relative;
            cursor: pointer;
            margin: 0 auto 12px;
            background: var(--white-primary);
            transition: all 0.2s ease;
        }

        .knob::after {
            content: '';
            position: absolute;
            width: 3px;
            height: 22px;
            background: var(--red-primary);
            top: 8px;
            left: 50%;
            transform: translateX(-50%) rotate(var(--rotation, -135deg));
            transform-origin: center 27px;
            transition: all 0.2s ease;
        }

        .knob:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .knob-label {
            font-size: 12px;
            color: var(--black-secondary);
            margin-bottom: 5px;
            font-family: 'ABC Camera Plain', sans-serif;
            font-weight: 400;
        }

        .knob-value {
            font-size: 14px;
            font-weight: 500;
            color: var(--red-primary);
            font-family: 'ABC Diatype Rounded', sans-serif;
        }

        /* Process Button */
        .process-btn {
            display: block;
            padding: 16px 48px;
            background: var(--black-primary);
            color: var(--white-primary);
            border: none;
            border-radius: 30px;
            font-size: 17px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'ABC Camera Plain', sans-serif;
            font-weight: 400;
            letter-spacing: 0.3px;
            margin: 30px auto 0;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
        }

        .process-btn:hover {
            background: var(--red-primary);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(182, 87, 93, 0.3);
        }

        /* Results/AB Player Interface */
        .results-container {
            display: none;
            width: 100%;
            max-width: 500px;
            text-align: center;
            background: var(--white-primary);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.08);
        }

        .result-title {
            font-family: 'ABC Diatype Rounded', sans-serif;
            font-size: 22px;
            margin-bottom: 30px;
            color: var(--black-tertiary);
        }

        .ab-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .ab-button {
            padding: 14px 28px;
            border: 2px solid var(--black-primary);
            background: transparent;
            border-radius: 25px;
            font-family: 'ABC Camera Plain', sans-serif;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--black-tertiary);
        }

        .ab-button.active {
            background: var(--black-primary);
            color: var(--white-primary);
        }

        .ab-button:hover {
            transform: translateY(-2px);
        }

        .player-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .play-button {
            width: 60px;
            height: 60px;
            border: 2px solid var(--black-primary);
            border-radius: 50%;
            background: var(--white-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .play-button:hover {
            background: var(--black-primary);
            color: var(--white-primary);
        }

        .play-icon {
            width: 0;
            height: 0;
            border-left: 15px solid currentColor;
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
            margin-left: 3px;
        }

        .pause-icon {
            width: 12px;
            height: 20px;
            border-left: 4px solid currentColor;
            border-right: 4px solid currentColor;
        }

        .download-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .download-btn {
            padding: 12px 24px;
            background: var(--red-primary);
            color: white;
            border: none;
            border-radius: 25px;
            font-family: 'ABC Camera Plain', sans-serif;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-block;
        }

        .download-btn:hover {
            background: var(--red-secondary);
            transform: translateY(-2px);
        }

        .reset-btn {
            background: transparent;
            color: var(--black-tertiary);
            border: 1px solid var(--gray-medium);
        }

        .reset-btn:hover {
            border-color: var(--teal-primary);
            color: var(--teal-primary);
            background: transparent;
        }

        /* Mobile Optimizations */
        @media (max-width: 640px) {
            .drop-text {
                font-size: 20px;
            }

            .recording-interface {
                width: 290px;
                height: 290px;
            }

            .interface-text {
                font-size: 22px;
            }

            .main-container {
                gap: 20px;
            }
            
            .model-status {
                bottom: 10px;
                right: 10px;
                font-size: 10px;
            }
        }

        /* Permissions Modal */
        .permissions-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(15, 15, 16, 0.1);
            text-align: center;
            z-index: 200;
        }

        .permissions-modal h3 {
            font-family: 'ABC Diatype Rounded', sans-serif;
            margin-bottom: 15px;
            color: var(--black-tertiary);
        }

        .permissions-modal p {
            font-size: 14px;
            color: var(--black-secondary);
            margin-bottom: 20px;
        }

        .permissions-button {
            padding: 12px 24px;
            background: var(--red-primary);
            color: white;
            border: none;
            border-radius: 25px;
            font-family: 'ABC Camera Plain', sans-serif;
            cursor: pointer;
        }

        #file-input {
            display: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">
            <span class="logo-text">roadshow</span>
            <span class="logo-studio">studio</span>
        </div>
        <div class="version">v11a3b epoch 319 | val loss: 9.02</div>
    </div>

    <!-- Model Status Indicator -->
    <div class="model-status" id="modelStatus">
        <span class="status-dot"></span>
        <span id="modelStatusText">checking model...</span>
    </div>

    <div class="main-container">
        <!-- Drop your sound text -->
        <div class="drop-text">
            <span class="word">drop</span>
            <span class="word">your</span>
            <span class="word sound">sound</span>
        </div>

        <!-- Recording Interface -->
        <div class="recording-interface" id="recordingInterface">
            <div class="event-horizon"></div>
            
            <!-- Orb emission container -->
            <div class="orb-container">
                <div class="orb teal"></div>
                <div class="orb red"></div>
                <div class="orb teal"></div>
                <div class="orb red"></div>
                <div class="orb teal"></div>
                <div class="orb red"></div>
            </div>
            
            <div class="inner-circle">
                <div class="interface-text">
                    tap to <span class="upload">upload</span><br>
                    hold to <span class="record">record</span>
                </div>
                
                <!-- Waveform visualization -->
                <div class="waveform-container" id="waveform">
                    <div class="waveform-bar" style="height: 10px"></div>
                    <div class="waveform-bar" style="height: 20px"></div>
                    <div class="waveform-bar" style="height: 15px"></div>
                    <div class="waveform-bar" style="height: 25px"></div>
                    <div class="waveform-bar" style="height: 18px"></div>
                    <div class="waveform-bar" style="height: 22px"></div>
                    <div class="waveform-bar" style="height: 12px"></div>
                    <div class="waveform-bar" style="height: 20px"></div>
                    <div class="waveform-bar" style="height: 16px"></div>
                </div>
            </div>
            <div class="recording-time" id="recordingTime">0:00</div>
        </div>

        <div class="file-drop-area" style="display: none;">
            <button class="file-button" onclick="document.getElementById('file-input').click()">
                choose file
            </button>
        </div>

        <!-- Controls Section -->
        <div class="controls-section" id="controlsSection">
            <div class="controls-title">shape your <span class="sound">sound</span></div>
            <div class="knobs-container">
                <div class="knob-control">
                    <div class="knob-label">clarity</div>
                    <div class="knob" id="clarityKnob" data-value="0.5"></div>
                    <div class="knob-value">0.5</div>
                </div>
                <div class="knob-control">
                    <div class="knob-label">warmth</div>
                    <div class="knob" id="warmthKnob" data-value="0.7"></div>
                    <div class="knob-value">0.7</div>
                </div>
            </div>
            
            <button class="process-btn" id="processBtn">apply studio magic</button>
        </div>

        <!-- Results Container -->
        <div class="results-container" id="resultsContainer">
            <h2 class="result-title">transformation complete</h2>
            
            <div class="ab-controls">
                <button class="ab-button active" id="originalBtn">original</button>
                <button class="ab-button" id="enhancedBtn">u87 enhanced</button>
            </div>

            <div class="player-controls">
                <button class="play-button" id="playButton">
                    <div class="play-icon" id="playIcon"></div>
                </button>
            </div>

            <div class="download-buttons">
                <button class="download-btn" id="downloadBtn" onclick="handleDownload()">download enhanced</button>
                <button class="download-btn reset-btn" onclick="resetInterface()">process another</button>
            </div>
        </div>
    </div>

    <!-- Processing Overlay -->
    <div class="processing-overlay" id="processingOverlay">
        <div class="processing-text">transforming your voice...</div>
        <div class="processing-progress">
            <div class="processing-progress-bar" id="progressBar"></div>
        </div>
    </div>

    <!-- Permissions Modal -->
    <div class="permissions-modal" id="permissionsModal">
        <h3>microphone access needed</h3>
        <p>roadshow needs access to your microphone to transform your voice</p>
        <button class="permissions-button" onclick="requestMicrophonePermission()">allow access</button>
    </div>

    <!-- Updated to accept .m4a files -->
    <input type="file" id="file-input" accept=".wav,.mp3,.m4a,.flac,.aac,.ogg,.webm">

    <script>
        // API Configuration - Use /api for Vercel proxy, or direct RunPod URL
        // For Vercel deployment: API calls go through /api which proxies to RunPod
        // For direct RunPod access: Use the full RunPod URL
        const IS_VERCEL = window.location.hostname.includes('vercel.app') || window.location.hostname === 'localhost';
        const API_URL = IS_VERCEL ? "/api" : "https://cdd65ozriziunh-8002.proxy.runpod.net";
        
        // State Management
        let mediaRecorder = null;
        let audioChunks = [];
        let recordingStartTime = null;
        let recordingTimer = null;
        let audioContext = null;
        let analyser = null;
        let microphone = null;
        let isRecording = false;
        let originalAudio = null;
        let enhancedAudio = null;
        let enhancedBlobUrl = null; // Store blob URL for download

        // DOM Elements
        const recordingInterface = document.getElementById('recordingInterface');
        const recordingTime = document.getElementById('recordingTime');
        const processingOverlay = document.getElementById('processingOverlay');
        const resultsContainer = document.getElementById('resultsContainer');
        const waveformBars = document.querySelectorAll('.waveform-bar');
        const innerCircle = recordingInterface.querySelector('.inner-circle');
        const interfaceText = recordingInterface.querySelector('.interface-text');
        const fileInput = document.getElementById('file-input');
        const modelStatus = document.getElementById('modelStatus');
        const modelStatusText = document.getElementById('modelStatusText');

        // Check Model Status on Load
        async function checkModelStatus() {
            try {
                const response = await fetch(`${API_URL}/health`);
                if (response.ok) {
                    const health = await response.json();
                    if (health.model_loaded) {
                        // Verify it's YOUR model, not vanilla BigVGAN
                        if (health.checkpoint === "epoch_319" && health.val_loss === "9.02") {
                            modelStatus.classList.add('connected');
                            modelStatusText.textContent = 'v11a3b epoch 319 loaded';
                        } else {
                            // Wrong model loaded!
                            modelStatus.classList.add('error');
                            modelStatusText.textContent = 'WARNING: vanilla bigvgan detected';
                            console.error('Wrong model loaded! Expected epoch 319, got:', health);
                        }
                    } else {
                        modelStatus.classList.add('error');
                        modelStatusText.textContent = 'model not loaded';
                    }
                } else {
                    modelStatus.classList.add('error');
                    modelStatusText.textContent = 'server offline';
                }
            } catch (error) {
                modelStatus.classList.add('error');
                modelStatusText.textContent = 'cannot connect';
                console.error('Model check failed:', error);
            }
        }

        // Check model status on page load
        checkModelStatus();
        // Re-check every 10 seconds
        setInterval(checkModelStatus, 10000);

        // Initialize Audio Context
        function initAudioContext() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 128;
        }

        // Add tap effect
        recordingInterface.addEventListener('mousedown', (e) => {
            if (!isHolding) {
                recordingInterface.classList.add('pulse');
            }
        });

        recordingInterface.addEventListener('touchstart', (e) => {
            if (!isHolding) {
                recordingInterface.classList.add('pulse');
            }
        });

        // Knob interactions
        document.querySelectorAll('.knob').forEach(knob => {
            let isDragging = false;
            let startY = 0;
            let startValue = 0;
            
            // Set initial rotation based on data-value
            const value = parseFloat(knob.dataset.value);
            const rotation = value * 270 - 135;
            knob.style.setProperty('--rotation', `${rotation}deg`);
            
            knob.addEventListener('mousedown', (e) => {
                isDragging = true;
                startY = e.clientY;
                startValue = parseFloat(knob.dataset.value);
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const deltaY = startY - e.clientY;
                const newValue = Math.max(0, Math.min(1, startValue + deltaY / 100));
                
                knob.dataset.value = newValue.toFixed(2);
                const rotation = newValue * 270 - 135;
                knob.style.setProperty('--rotation', `${rotation}deg`);
                knob.parentElement.querySelector('.knob-value').textContent = newValue.toFixed(1);
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // Touch support for knobs
            knob.addEventListener('touchstart', (e) => {
                isDragging = true;
                startY = e.touches[0].clientY;
                startValue = parseFloat(knob.dataset.value);
                e.preventDefault();
            });
            
            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                
                const deltaY = startY - e.touches[0].clientY;
                const newValue = Math.max(0, Math.min(1, startValue + deltaY / 100));
                
                knob.dataset.value = newValue.toFixed(2);
                const rotation = newValue * 270 - 135;
                knob.style.setProperty('--rotation', `${rotation}deg`);
                knob.parentElement.querySelector('.knob-value').textContent = newValue.toFixed(1);
            });
            
            document.addEventListener('touchend', () => {
                isDragging = false;
            });
        });

        // Remove pulse effect after animation
        recordingInterface.addEventListener('animationend', () => {
            if (!isRecording) {
                recordingInterface.classList.remove('pulse');
            }
        });

        // Touch/Mouse Event Handlers
        let isHolding = false;
        let holdTimer = null;
        let didStartHold = false;

        // Unified event handlers for both touch and mouse
        function handleInteractionStart(e) {
            e.preventDefault();
            isHolding = true;
            didStartHold = false;
            
            // Set a timer to determine if it's a hold
            holdTimer = setTimeout(() => {
                didStartHold = true;
                handleRecordingStart();
            }, 200); // Start recording after 200ms hold
        }

        function handleInteractionEnd(e) {
            e.preventDefault();
            clearTimeout(holdTimer);
            
            if (isHolding) {
                isHolding = false;
                
                if (didStartHold) {
                    // Was holding - stop recording
                    handleRecordingStop();
                } else {
                    // Was just a tap - trigger file upload
                    recordingInterface.classList.add('pulse');
                    fileInput.click();
                }
            }
        }

        // Add both touch and mouse listeners
        recordingInterface.addEventListener('mousedown', handleInteractionStart);
        recordingInterface.addEventListener('touchstart', handleInteractionStart);

        document.addEventListener('mouseup', handleInteractionEnd);
        document.addEventListener('touchend', handleInteractionEnd);
        document.addEventListener('touchcancel', handleInteractionEnd);

        // Prevent context menu on long press
        recordingInterface.addEventListener('contextmenu', e => e.preventDefault());

        // Handle Recording Start
        async function handleRecordingStart() {
            if (!audioContext) initAudioContext();

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                recordingInterface.classList.add('recording');
                recordingInterface.classList.remove('pulse');
                interfaceText.innerHTML = 'recording...';
                
                // Set up MediaRecorder - try to use m4a/aac if available
                const mimeType = MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4' :
                                MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : 
                                'audio/ogg';
                
                mediaRecorder = new MediaRecorder(stream, { mimeType });
                audioChunks = [];
                
                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };
                
                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: mimeType });
                    window.recordedBlob = audioBlob;
                    showControls();
                };
                
                // Set up analyser for visualization
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                
                // Start recording
                mediaRecorder.start();
                recordingStartTime = Date.now();
                isRecording = true;
                
                // Update timer
                updateRecordingTime();
                
                // Start visualization
                visualizeAudio();
                
            } catch (error) {
                console.error('Microphone access denied:', error);
                document.getElementById('permissionsModal').style.display = 'block';
            }
        }

        // Handle Recording Stop
        function handleRecordingStop() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                
                recordingInterface.classList.remove('recording');
                interfaceText.innerHTML = 'processing...';
                
                isRecording = false;
                clearInterval(recordingTimer);
                
                if (microphone) {
                    microphone.disconnect();
                }
            }
        }

        // Update Recording Timer
        function updateRecordingTime() {
            recordingTimer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                recordingTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }, 100);
        }

        // Audio Visualization
        function visualizeAudio() {
            if (!isRecording) return;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            // Update waveform bars
            waveformBars.forEach((bar, index) => {
                const value = dataArray[index * 4] || 0;
                const height = Math.max(5, (value / 255) * 30);
                bar.style.height = `${height}px`;
            });

            requestAnimationFrame(visualizeAudio);
        }

        // File Input Handler
        fileInput.addEventListener('change', async (e) => {
            if (e.target.files.length > 0) {
                const file = e.target.files[0];
                window.selectedFile = file;
                showControls();
            }
        });

        // Show controls after file selection/recording
        function showControls() {
            recordingInterface.style.display = 'none';
            document.querySelector('.drop-text').style.display = 'none';
            document.getElementById('controlsSection').style.display = 'block';
        }

        // Smart download - works on Vercel, falls back to new tab on RunPod
        function handleDownload() {
            if (!window.enhancedAudioBlob) {
                console.error('No enhanced audio blob');
                alert('No enhanced audio available. Please process audio first.');
                return;
            }

            // Check if we're in RunPod iframe (downloads blocked)
            const inRunPodIframe = window.location.hostname.includes('proxy.runpod.net');
            
            if (!inRunPodIframe) {
                // Normal download (works on Vercel/direct hosting)
                try {
                    const url = URL.createObjectURL(window.enhancedAudioBlob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = `roadshow_u87_v11a3b_${Date.now()}.wav`;
                    document.body.appendChild(a);
                    a.click();
                    
                    setTimeout(() => {
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    }, 100);
                    
                    console.log('Download triggered successfully');
                    return;
                } catch (e) {
                    console.error('Download failed:', e);
                }
            }
            
            // Fallback for RunPod: Open in new tab
            const url = URL.createObjectURL(window.enhancedAudioBlob);
            const newWindow = window.open(url, '_blank');
            
            if (newWindow && inRunPodIframe) {
                setTimeout(() => {
                    alert('RunPod blocks downloads. Right-click the audio and select "Save audio as..." to download.');
                }, 500);
            } else if (!newWindow) {
                // Try data URL if popup blocked
                if (window.enhancedAudioBase64) {
                    const dataUrl = 'data:audio/wav;base64,' + window.enhancedAudioBase64;
                    window.open(dataUrl, '_blank');
                }
            }
        }

        // Process Button Handler - UPDATED FOR v11a3b RUNPOD API
        document.getElementById('processBtn').addEventListener('click', async () => {
            if (!window.selectedFile && !window.recordedBlob) {
                alert('Please record or upload audio first');
                return;
            }

            const clarity = parseFloat(document.getElementById('clarityKnob').dataset.value);
            const warmth = parseFloat(document.getElementById('warmthKnob').dataset.value);

            // Update model status to show processing
            modelStatus.classList.remove('connected', 'error');
            modelStatus.classList.add('processing');
            modelStatusText.textContent = 'processing with v11a3b...';

            // Show processing overlay
            processingOverlay.style.display = 'flex';
            document.getElementById('controlsSection').style.display = 'none';

            // Animate progress bar
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress += Math.random() * 15;
                if (progress > 90) progress = 90;
                document.getElementById('progressBar').style.width = `${progress}%`;
            }, 200);

            try {
                const audioFile = window.recordedBlob || window.selectedFile;
                
                // Create FormData for direct upload to RunPod server
                const formData = new FormData();
                formData.append('file', audioFile, audioFile.name || 'audio.m4a');
                
                console.log(`Sending request to: ${API_URL}/process?clarity=${clarity}&warmth=${warmth}`);
                
                // Call v11a3b inference server directly
                const response = await fetch(`${API_URL}/process?clarity=${clarity}&warmth=${warmth}`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API request failed: ${response.status} - ${errorText}`);
                }

                const result = await response.json();
                console.log('Processing result:', result);
                
                // Verify we used the right model
                if (result.model !== "v11a3b_epoch_319") {
                    console.warn('WARNING: Response from unexpected model:', result.model);
                    modelStatus.classList.add('error');
                    modelStatusText.textContent = 'wrong model used!';
                }
                
                // Complete progress
                clearInterval(progressInterval);
                document.getElementById('progressBar').style.width = '100%';
                
                // CRITICAL: Store base64 AND blob for download fallbacks
                window.enhancedAudioBase64 = result.audio_base64;
                
                // Decode base64 audio
                const audioData = atob(result.audio_base64);
                const arrayBuffer = new ArrayBuffer(audioData.length);
                const view = new Uint8Array(arrayBuffer);
                for (let i = 0; i < audioData.length; i++) {
                    view[i] = audioData.charCodeAt(i);
                }
                const audioBlob = new Blob([arrayBuffer], { type: 'audio/wav' });
                
                // CRITICAL: Store blob globally for download
                window.enhancedAudioBlob = audioBlob;
                
                // Create blob URL for audio playback
                enhancedBlobUrl = URL.createObjectURL(audioBlob);
                
                // Set up audio players
                originalAudio = new Audio(URL.createObjectURL(audioFile));
                enhancedAudio = new Audio(enhancedBlobUrl);
                
                // Update model status back to connected
                modelStatus.classList.remove('processing');
                modelStatus.classList.add('connected');
                modelStatusText.textContent = 'v11a3b epoch 319 loaded';
                
                // Show results
                setTimeout(() => {
                    processingOverlay.style.display = 'none';
                    resultsContainer.style.display = 'block';
                }, 500);

            } catch (error) {
                console.error('Processing error:', error);
                clearInterval(progressInterval);
                
                // Update model status to show error
                modelStatus.classList.remove('processing');
                modelStatus.classList.add('error');
                modelStatusText.textContent = 'processing failed';
                
                alert(`Processing failed: ${error.message}\n\nMake sure your RunPod server is running and the URL is correct.`);
                resetInterface();
            }
        });

        // Drag and Drop
        recordingInterface.addEventListener('dragover', (e) => {
            e.preventDefault();
            recordingInterface.classList.add('pulse');
        });

        recordingInterface.addEventListener('dragleave', () => {
            recordingInterface.classList.remove('pulse');
        });

        recordingInterface.addEventListener('drop', async (e) => {
            e.preventDefault();
            recordingInterface.classList.remove('pulse');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                window.selectedFile = files[0];
                showControls();
            }
        });

        // Audio A/B Testing
        let currentAudio = null;
        let isPlaying = false;

        document.getElementById('originalBtn').addEventListener('click', () => {
            document.getElementById('originalBtn').classList.add('active');
            document.getElementById('enhancedBtn').classList.remove('active');
            
            if (currentAudio) currentAudio.pause();
            currentAudio = originalAudio;
            if (isPlaying) currentAudio.play();
        });

        document.getElementById('enhancedBtn').addEventListener('click', () => {
            document.getElementById('enhancedBtn').classList.add('active');
            document.getElementById('originalBtn').classList.remove('active');
            
            if (currentAudio) currentAudio.pause();
            currentAudio = enhancedAudio;
            if (isPlaying) currentAudio.play();
        });

        // Play/pause button
        document.getElementById('playButton').addEventListener('click', () => {
            const playIcon = document.getElementById('playIcon');
            
            if (!currentAudio) currentAudio = originalAudio;

            if (isPlaying) {
                currentAudio.pause();
                playIcon.className = 'play-icon';
                isPlaying = false;
            } else {
                currentAudio.play();
                playIcon.className = 'pause-icon';
                isPlaying = true;
            }
        });

        // Reset Interface
        function resetInterface() {
            recordingInterface.style.display = 'block';
            document.querySelector('.drop-text').style.display = 'block';
            document.getElementById('controlsSection').style.display = 'none';
            resultsContainer.style.display = 'none';
            interfaceText.innerHTML = 'tap to <span class="upload">upload</span><br>hold to <span class="record">record</span>';
            recordingTime.textContent = '0:00';
            
            window.selectedFile = null;
            window.recordedBlob = null;
            window.enhancedAudioBlob = null;
            window.enhancedAudioBase64 = null;
            
            // Clean up blob URLs
            if (enhancedBlobUrl) {
                URL.revokeObjectURL(enhancedBlobUrl);
                enhancedBlobUrl = null;
            }
            
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            
            if (originalAudio) {
                URL.revokeObjectURL(originalAudio.src);
                originalAudio = null;
            }
            
            if (enhancedAudio) {
                enhancedAudio = null;
            }
            
            isPlaying = false;
            document.getElementById('playIcon').className = 'play-icon';
        }

        // Request Microphone Permission
        async function requestMicrophonePermission() {
            try {
                await navigator.mediaDevices.getUserMedia({ audio: true });
                document.getElementById('permissionsModal').style.display = 'none';
            } catch (error) {
                alert('Microphone access is required for recording. Please enable it in your browser settings.');
            }
        }

        // Check for WebRTC support
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            interfaceText.innerHTML = 'recording not supported';
            document.querySelector('.interface-subtext').innerHTML = 'please use file upload';
        }

        // Log API URL and model info for debugging
        console.log(`Roadshow v11a3b - Epoch 319 - API URL: ${API_URL}`);
        console.log('Looking for checkpoint at: /workspace/training/bigvgan_u87_training/checkpoints/bigvgan_u87_v11a3b_phase_c50/bigvgan_u87_v11a_original_250_clean_epoch_319.pth');
    </script>
</body>
</html>